# 1.前言

之前一直想对实验室的小车项目来做一个具体的剖析，但碍于各种原因，一直没能写成，今天是2023.7.28号，这篇文章就从今天开始写起吧。

写这篇文章的目的在于，我希望把这个工程具体的难点记录下来，例如具体用到的技术，具体用到的编程语言的细节等等，需要经过思考，然后记录下来以便后期回顾。万事开头难，我也希望我能坚持下去，把这篇博文写好。



**为什么该项目需要使用freertos？**

1. **多任务调度**：FreeRTOS是一个实时操作系统，支持多任务调度。开发者可以将应用程序划分为多个任务，并通过FreeRTOS提供的任务调度器分配CPU时间给各个任务，以实现并行执行。相比之下，裸机开发通常是单一任务的，程序会按照顺序一步步执行。

2. **资源管理**：FreeRTOS提供了一套丰富的资源管理机制，如任务间通信（如消息队列、信号量、邮箱等）、任务同步（如互斥锁、事件标志、任务通知等）和定时器等。这些机制可以帮助开发者更好地管理和分配系统资源，同时协调不同任务之间的操作。在裸机开发中，需要自行实现这些资源管理机制。

3. **稳定性和可靠性**：FreeRTOS经过严格的测试和验证，具有一定的稳定性和可靠性。其提供的任务调度和资源管理机制经过实践证明，可以在实时应用中提供可靠的性能和可预测的响应。裸机开发在资源管理和任务调度方面相对简单，但缺乏操作系统提供的稳定性和可靠性保证。

4. **可移植性**：FreeRTOS具有较高的可移植性，在各种硬件平台上都能够运行。它提供了通用的API和配置接口，能够适应不同的处理器架构和外设。而裸机开发往往需要针对具体硬件平台进行定制开发，可移植性较差。

5. **开发效率**：使用FreeRTOS能够提高开发效率，开发者可以更专注于应用程序的逻辑，而无需关注底层细节和调度管理。裸机开发需要自行编写所有的底层代码和调度逻辑，会消耗更多的时间和精力。

# 2.机器人的运动学分析

机器人的目标速度转换成电机的目标速度这个过程叫“运动学分析”，运动学分析又分为正解和逆解

1. **运动学正解：通过机器人的各轮速度求出机器人 X 轴、Y 轴和 Z 轴方向的速度。**
2. **运动学逆解：通过机器人 X 轴、Y 轴和 Z 轴方向的速度分别求出机器人各轮的速度。**





## **2.1 两轮差速小车**

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230728195856512.png" alt="image-20230728195856512" style="zoom:50%;" />

机器人两个轮子之间的间距为 D，机器人 X 轴和 Z 轴的速度分别为：Vx 和Vz ，机器人左轮和右轮速度分别为：VL和VR 

![image-20230728195948119](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230728195948119.png)

```c++
/**************************************************************************
函数功能：对接收到数据进行处理
入口参数：X和Y Z轴方向的运动速度
返回  值：无
**************************************************************************/
void Drive_Motor(float Vx,float Vy,float Vz)
{
	float amplitude = MAX_SPEED; // 对应900r
	
//	//履带车

		//printf("g_emCarMode = %d\r\n", g_emCarMode);
        // 运动学逆解
		MOTOR_A.fltTarget_velocity = Vx - Vz * (Wheel_spacing) / 2.0f;    //计算出左轮的目标速度
		MOTOR_B.fltTarget_velocity = Vx + Vz * (Wheel_spacing) / 2.0f;    //计算出右轮的目标速度		

		// 车轮(电机)目标速度限幅
		MOTOR_A.fltTarget_velocity = target_limit_float( MOTOR_A.fltTarget_velocity,-amplitude,amplitude); //速度限幅
		MOTOR_B.fltTarget_velocity = target_limit_float( MOTOR_B.fltTarget_velocity,-amplitude,amplitude); //速度限幅
				
		MOTOR_C.fltTarget_velocity = 0;
		MOTOR_D.fltTarget_velocity = 0;
		
		MOTOR_A.nTarget_Velocity = SpeedVelocityToRotate(MOTOR_A.fltTarget_velocity); //m/s轮胎转速
		MOTOR_B.nTarget_Velocity = SpeedVelocityToRotate(MOTOR_B.fltTarget_velocity);
		MOTOR_C.nTarget_Velocity = SpeedVelocityToRotate(MOTOR_C.fltTarget_velocity);
		MOTOR_D.nTarget_Velocity = SpeedVelocityToRotate(MOTOR_D.fltTarget_velocity);


//	}
}
```



## 2.2 阿克曼小车

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230728171652339.png" alt="image-20230728171652339" style="zoom:50%;" />

### 1.运动学分析

而此时要使阿克曼小车实现纯滚动运动，则**必须保证小车的四个轮运动方向的法线相交于一点**，该点则为转向中心点,如图点 O。

为简化模型，**设前轮只有一个轮子(实现理论是一致的)，位于前轮轴中间位置上**，如图虚线部分描绘的前轮所示

![image-20230728173300688](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230728173300688.png)

c语言实现：

具体代码在balance.c文件中



```c++
/**************************************************************************
函数功能：将线速度和角速度转化为电机的输入值
入口参数：角速度线速度
返回  值：无
**************************************************************************/
void Kinematic_Analysis(float Vx, float Vy, float Vz)
{
	float angle = 0;
	Vz=-Vz;
//	if (Vx > 0)
//	{
//		angle = atan(Axle_spacing * Vz / Vx);
//		MOTOR_B.fltTarget_velocity = Vx + (Wheel_spacing * Vz / 2);
//		MOTOR_C.fltTarget_velocity = Vx - (Wheel_spacing * Vz / 2);
//	}
//	else if (Vx < 0)
//	{
//		angle = -atan(Axle_spacing * Vz / Vx);
//		MOTOR_B.fltTarget_velocity = Vx - (Wheel_spacing * Vz / 2);
//		MOTOR_C.fltTarget_velocity = Vx + (Wheel_spacing * Vz / 2);
//	}
//	else
//	{
//		angle = atan(Axle_spacing * Vz / (Vx + 0.5));
//		MOTOR_B.fltTarget_velocity = 0;
//		MOTOR_C.fltTarget_velocity = 0;
//	}
	
	if(Vx>0)
	{
		if(Vz>0)
		{
					MOTOR_B.fltTarget_velocity = fabs(Vx) + (Wheel_spacing * fabs(Vz) / 2);
					MOTOR_C.fltTarget_velocity = fabs(Vx) - (Wheel_spacing * fabs(Vz) / 2);
		}
		else
		{
					MOTOR_B.fltTarget_velocity = fabs(Vx) - (Wheel_spacing * fabs(Vz) / 2);
					MOTOR_C.fltTarget_velocity = fabs(Vx) + (Wheel_spacing * fabs(Vz) / 2);
		}
		angle = atan(Axle_spacing * Vz / Vx);

	}
	else if(Vx <0)
	{
		if(Vz<0)
		{
					MOTOR_B.fltTarget_velocity = -(fabs(Vx) + (Wheel_spacing * fabs(Vz) / 2));
					MOTOR_C.fltTarget_velocity = -(fabs(Vx) - (Wheel_spacing * fabs(Vz) / 2));
		}
		else
		{
					MOTOR_B.fltTarget_velocity = -(fabs(Vx) + (Wheel_spacing * fabs(Vz) / 2));
					MOTOR_C.fltTarget_velocity = -(fabs(Vx) - (Wheel_spacing * fabs(Vz) / 2));
		}
		angle = atan(Axle_spacing * Vz / Vx);
	}
	else
	{
		angle =0;
		MOTOR_B.fltTarget_velocity = 0;
		MOTOR_C.fltTarget_velocity = 0;
	}


//	printf("angle %f \r\n",angle);
//	printf("X %f \r\n",Vx);
//	printf("Y %f \r\n",Vz);
	angle = target_limit_float(angle, -0.471, 0.471);

	Servo_pulse = angle * 452674;
  
	MOTOR_B.nTarget_Velocity = -SpeedVelocityToRotate(MOTOR_B.fltTarget_velocity);
	MOTOR_C.nTarget_Velocity = SpeedVelocityToRotate(MOTOR_C.fltTarget_velocity);
	
	if(Vx==0&&ROS_ON_Flag==0&&Abs_int(tagSBUS_CH.CH7 - TURN_ON_REMOOT) < 10)
	{
		Servo_pulse = (float)(tagSBUS_CH.CH1-1023)/787*220000;

	}
	
	
}
```

函数输入为 X 和 Y 轴速度和前轮转向角度，Axle_Spacing 为小车(前后)轴距参数(H)，Wheel_spacing 为小车(左右)轮距参数(D)

```c++
angle = atan(Axle_spacing * Vz / Vx);//这个有点不懂
```





# 3.**PI** 控制程序源码

通过运动学分析得到的是电机的目标速度，我们需要把这个目标值送入 PID控制器进行速度闭环控制，使得电机的实际输出速度趋近于目标值。

​      阿克曼车代码

没有使用到PID控制

```c++
/**************************************************************************
函数功能：使用速度模式对舵机进行PIP控制,最终得到电机的输入值
入口参数：无
返回  值：无
**************************************************************************/
void Servo_PID()
{   //Servo_pulse = angle * 452674;一个与角度相关的值
	if (abs(Servo_pulse - (int)(-1) * (uVelServo.nVelcity)) > 5000)
	{
		MOTOR_A.nTarget_Velocity = 0.02 * (Servo_pulse - (int)(-1) * (uVelServo.nVelcity));
		if (MOTOR_A.nTarget_Velocity < 300 && MOTOR_A.nTarget_Velocity > 0)
		{
			MOTOR_A.nTarget_Velocity = 300;
		}
		if (MOTOR_A.nTarget_Velocity > -300 && MOTOR_A.nTarget_Velocity < 0)
		{
			MOTOR_A.nTarget_Velocity = -300;
		}
	}
	if (abs(Servo_pulse - (int)(-1) * (uVelServo.nVelcity)) < 5000)
	{
		MOTOR_A.nTarget_Velocity = 0.01 * (Servo_pulse - (int)(-1) * (uVelServo.nVelcity));
	}
}
```

教程

```c++
PI 控制器源码如下所示：
/**************************************************************************
* 函数功能：增量 PI 控制器速度控制
* 入口参数：Encoder：编码器测量值、Target：目标速度
* 返 回 值：Pwm：电机 PWM
* 函数说明：pwm+=Kp[e（k）-e(k-1)]+Ki*e(k) 增量式 PI 控制
**************************************************************************/
int Incremental_PI_A (float Encoder,float Target)
{
static float Bias,Pwm,Last_bias;
Bias=Target-Encoder; //计算偏差
Pwm+=Velocity_KP*(Bias-Last_bias)+Velocity_KI*Bias; //增量式 PI 控制器
if(Pwm>7200)Pwm=7200;
if(Pwm<-7200)Pwm=-7200;
Last_bias=Bias; //保存上一次偏差
return Pwm; //增量输出
}
```

增量式PI控制器在电机PWM速度控制中应用广泛，有以下几个原因：

1. **实时性**：增量式PI控制器能够实时地根据当前误差调整输出信号，因此非常适合对电机PWM进行实时控制。它不需要记录历史误差或累积误差，只需要当前的误差和前一次的输出值即可。
2. **稳定性**：电机控制系统中的速度控制往往需要快速响应并保持稳定。增量式PI控制器通过使用比例和积分项来控制输出，能够在系统出现扰动或变化时快速调整，并迅速回到设定的目标速度。
3. **线性化**：通过增量式PI控制器可以将非线性的电机速度控制问题转化为线性的控制问题。通过精心调整比例和积分参数，可以使得系统在不同负载、不同速度要求下表现稳定且线性。
4. **易于调试**：增量式PI控制器的参数调整相对较简单。增量式PI控制器只有两个参数，即比例增益和积分时间常数。这使得调试和优化系统变得更加方便。

综上所述，增量式PI控制器在电机PWM速度控制中被广泛使用，它能够提供实时性、稳定性、线性化和易于调试的优点，帮助实现精确的速度控制和响应要求。



## 1.PID控制

[PID控制](https://so.csdn.net/so/search?q=PID控制&spm=1001.2101.3001.7020)：一种调节器控制规律为比例、积分、微分的控制。其中：P：比例（proportion）I：积分（integral）D：微分（derivative）

1.增量式PID

所谓增量，就是本次控制量和上次控制量的差值，常用于对电机的转速控制。增量式PID是一种对控制量的增量进行PID控制的一种控制算法。

其公式为：

![image-20230728212101995](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20230728212101995.png)

```c++
/*
增量式PID
P = Kp * (err - err_pre);
I = Ki * err;
D = Kd * (err - 2 * err_pre + err_pre_pre);
pwm = P + I + D;
*/
void PID
{
    err = speed_want - speed_now; // speed_now是反馈量，可以通过编码器采值等方式得到
    
    P = Kp * (err - err_pre);
    I = Ki * err;
    D = Kd * (err - 2 * err_pre + err_pre_pre);
    
    pwm_duty += (int)(P + I + D); //这里的加号就是增量式PID的体现
 
    err_pre_pre = err_pre;
    err_pre = err;
}
```



**重要问题： 增量式pid调节目标速度时候参数整定**

 先加大KI，这时候会越来越接近实际速度，当KI过大的时候，在切换目标速度的时候，就会抖动，这时候就是KI大了响应速度高了，但导致超调量增加，这时候就   加大增量式的KP，来缓减抖动，减小超调量。 

 增量式pid调节目标位置时候参数整定： 

经过我自己的实验，增量式pid的位置控制，只用比例参数就够了，把kp从小往大了调，过小响应慢，过大反应会来回摆动。而如果加上积分参数的话，会来回转    的很厉害，可能正是因为它和位置式的p很相似，并且他是一直在+=



## 2.增量式PID调节电机速度（霍尔编码器）实验

参考资料：[(100条消息) 平衡小车—TB6612FNG与直流电机控制教程_tb6612接线图_果果小师弟的博客-CSDN博客](https://blog.csdn.net/qq_39400113/article/details/107578869?ops_request_misc=%7B%22request%5Fid%22%3A%22162044467816780264077994%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=162044467816780264077994&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-4-107578869.first_rank_v2_pc_rank_v29&utm_term=TB6612)

[(100条消息) STM32cubeMX--增量式PID调节电机速度（霍尔编码器）_编码器电机调速_QWQ_DIODA的博客-CSDN博客](https://blog.csdn.net/QWQ_DIODA/article/details/116519580?ops_request_misc=%7B%22request%5Fid%22%3A%22169076689816800213067453%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169076689816800213067453&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-116519580-null-null.142^v91^insertT0,239^v12^control2&utm_term=霍尔编码器电机pid控制&spm=1018.2226.3001.4187)

### 1.原理图：

接线参考：[Stm32-使用TB6612驱动电机及编码器测速_tb6612电机驱动原理图_藕粉-的博客-CSDN博客](https://blog.csdn.net/cyaya6/article/details/129636599?ops_request_misc=%7B%22request%5Fid%22%3A%22169095757416800211529553%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169095757416800211529553&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129636599-null-null.142^v92^controlT0_2&utm_term=tb6612与编码器电机接线&spm=1018.2226.3001.4187)

![image-20230731105535608](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230731105535608.png)

上图中红色部分的5个引脚控制一路电机，蓝色部分的控制另外一路电机，这里只讲其中的A 路，B路的使用是一样的。AO1 和AO2 分别接到电机的+和-。然后通过PWMA、AIN2、AIN1控制电机。其中PWMA 接到单片机的PWM 引脚，一般10Khz 的PWM 即可，并通过改变占空比来调节电机的速度。下面是真值表：

**然后编码器A相和编码器B相需要连接到stm32定时器编码器的CH1和CH2上**

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230731110525974.png" alt="image-20230731110525974" style="zoom:50%;" />







<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230731102905976.png" alt="image-20230731102905976" style="zoom: 67%;" />

![image-20230731103147608](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230731103147608.png)



使用TIM3作为PWM的输出

TIM2作为编码器的输入

### **2增量式编码器**

参考资料：

[(100条消息) 定时器之编码器模式_定时器的编码器模式_牛牛ly的博客-CSDN博客](https://blog.csdn.net/qq_41328470/article/details/127956500?ops_request_misc=%7B%22request%5Fid%22%3A%22169079227816800211547828%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169079227816800211547828&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-127956500-null-null.142^v91^insertT0,239^v12^control2&utm_term=定时器的编码器模式&spm=1018.2226.3001.4187)

 增量式编码器：增量式编码器通常有3个信号输出，分别为A相、B相、Z相（有些也标称为C相）输出，A相与B相之间相互延迟1/4周期（90度）的脉冲输出，根据延迟关系可以区别正反转，而且**通过取A相、B相的上升和下降沿可以进行2或4倍频；Z相为单圈脉冲，即每圈发出一个脉冲**。 增量测量法的光栅由周期性栅条组成。位置信息通过计算自某点开始的增量数(测量步距数)获得。由于必须用绝对参考点确定位置值，因此圆光栅码盘还有一个参考点轨。将位移转换成周期性的电信号，再把这个电信号转变成计数脉冲，用脉冲的个数表示位移的大小。
![image-20230731163558054](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230731163558054.png)

 **当A相的上升沿B相对应是低电平就是正转， 当A相的上升沿B相对应是高电平就是反转**



### 3.STM32的编码器

参考资料：

[(100条消息) 【STM32】 定时器---正交解码编码器模式详解_正交编码器的工作原理_Z小旋的博客-CSDN博客](https://blog.csdn.net/as480133937/article/details/98750922?ops_request_misc=%7B%22request%5Fid%22%3A%22169079227816800211547828%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169079227816800211547828&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-98750922-null-null.142^v91^insertT0,239^v12^control2&utm_term=定时器的编码器模式&spm=1018.2226.3001.4187)

**编码器线数：**
编码器的线数 ,是说编码器转一圈输出多少个脉冲,如果一个编码器是500线,说明这个编码器转一圈对应的信号线会输出500个脉冲, A B两相转一圈发出的脉冲数一样的,不过存在90°相位差

线数越高代表编码器能够反应的位置精度越高

**编码器原理：**
增量式编码器有两个脉冲输出，A相和B相，并且两个相位永远存在90°相位差。 如果两个信号相位差为90度，则这两个信号称为正交。由于两个信号相差90度，因此可以根据两个信号哪个先哪个后来判断方向、并且可以根据AB相脉冲信号数量测得速度，位移等，

**正转的时候信号线A先输出信号,信号线B后输出 A相超前B相90度 证明是正转**

**反转的时候信号线B先输出信号,信号线A后输出 B相超前A相90度 证明是反转**





**STM32定时器编码器模式**

STM32的编码器模式共有三种：

-  **仅在TL1计数(A相)**
-  **仅在TL2计数(B相)**
-  **在TL1和TL2都计数(A相和B相都计数)**



**在TL1和TL2都计数(A相和B相都计数)**

![image-20230731171558474](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230731171558474.png)

**一个脉冲信号周期完成4次跳变。精度提高**

**1时刻：TI2为低电平，TI1上升沿跳变，计数器向上计数；**

**2时刻：TI1为高电平，TI2上升沿跳变，计数器仍然向上计数；**

**3时刻：TI2为高电平，TI1下降沿跳变，计数器仍然向上计数；**

**4时刻：TI1为低电平，TI2下降沿跳变，计数器仍然向上计数。**

**毛刺：只有一个相位脉冲  过滤掉 编码器转动过程中可能产生的毛刺过滤掉**

**计数器向下计数原理相同  看图即可很好理解。**

**计数器向下计数：**

A下降沿，B低电平
B下降沿，A高电平
B上升沿，A低电平
A上升沿，B高电平





注意事项：

- 需要增加测量的精度时，可以采用4倍频方式，即分别在A、B相波形的上升沿和下降沿计数，分辨率可以提高4倍，
- 如果只是测速,不要求方向，那么只需要用单片机随意选择一个信号线就行了,,然后定时器边沿触发，检测脉冲计数即可
- 一般是定时器的通道1和2才能作为编码器输入口，对应编码器输出的两相。
- GPIO配置为配置为上拉输入模式
- 一个定时器做一种工作，如果你配置了编码器模式，那么剩下的通道就不能配置其他模式
- **两相计数模式下，  读出来数需要/4          一个脉冲信号对应四次计数** 



编码器模式功能：
  stm32f407中定时器1、2、3、4、5、8提供编码器接口模式 
  可以对输入信号TI1,TI2进行滤波处理，数字滤波器由事件器组成，每N个事件才视为一个有效边沿，可以在TIMx_CCMR1、TIMx_CCMR2中的IC1F位域设置      也就是可以设置每产生几次脉冲才视为1次有效  
各个值的计算：
**转速计算方法:用捕获值（一秒内输出的脉冲数）/编码器线数（转速一圈输出脉冲数）/电机减数比（内部电机转动圈数与电机输出轴转动圈数比，即减速齿轮比    没有则不用除）**/**倍频计数**

**运动距离计算**：输出的总脉冲数 / 编码器线数*编码器齿轮周长

**所转角度计算**：    输出的总脉冲数 / 编码器线数 *360     或    溢出中断次数*360+当前计数值 

转动方向： 方向在定时器CR1的DIR位里   dir=(TIMX->CR1 & 0x0010)>>4;     //取方向标志位
if(dir > 0)  //向下计数     else     //向上计数



### **4.电机转轴转速计算**

参考资料：[(100条消息) 电机控制基础——定时器编码器模式使用与转速计算_电机定时器怎么读取编码器的速度_码农爱学习的博客-CSDN博客](https://blog.csdn.net/hbsyaaa/article/details/114715319?ops_request_misc=%7B%22request%5Fid%22%3A%22169079227816800211547828%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169079227816800211547828&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-114715319-null-null.142^v91^insertT0,239^v12^control2&utm_term=定时器的编码器模式&spm=1018.2226.3001.4187)

这里使用一款直流减速电机：

减速比是34（即电机转轴转1圈，电机本身要转34圈）
电机转一圈的物理脉冲数是11
所以，电机转轴转1圈时，可以产生的物理脉冲为34*11=374个，又由于编码器器模式实现了4倍频计数，所以，电机转轴转1圈时，定时器可以计数374×4=1496个。

对于转速的计算，这里使用M法测速（M法测速的具体原理参考之前的文章：），即统计固定时间间隔内的编码器的脉冲数，来计算速度值。



![image-20230731172305327](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20230731172305327.png)

比如，对于本次实验的电机，转轴转1圈时，定时器计数1496个，即C=149    6个，对应程序中的`TOTAL_RESOLUTION`。T0可以选择100ms，即0.1s。



### 5.项目中的测速

```c++
  //编码器倍频数 编码器频率
#define   EncoderMultiples 4
Robot_Parament.GearRatio=gearratio;               //电机减速比
Robot_Parament.EncoderAccuracy=Accuracy;          //编码器精度(电机驱动线数)
Encoder_precision=EncoderMultiples*Robot_Parament.EncoderAccuracy*Robot_Parament.GearRatio;//编码器精度
```

阿克曼车

电机减速比：30

编码器：13pcr(电机转一圈的物理脉冲数是13)

```c++
MOTOR_A.Encoder= Encoder_A_pr*CONTROL_FREQUENCY*Wheel_perimeter/Encoder_precision;  //编码器的数据转换  计算出单位时间内的速度m/s
//Encoder_A_pr 编码器原始数据
//CONTROL_FREQUENCY 100
//Wheel_perimeter轮子周长
```

 

### 6.pid控制电机实验

实验项目：17.PID_motor中的pwm文件夹中

参考资料：[STM32cubeMX--增量式PID调节电机速度（霍尔编码器）_编码器电机调速_QWQ_DIODA的博客-CSDN博客](https://blog.csdn.net/QWQ_DIODA/article/details/116519580?ops_request_misc={"request_id"%3A"169076689816800213067453"%2C"scm"%3A"20140713.130102334.."}&request_id=169076689816800213067453&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-116519580-null-null.142^v91^insertT0,239^v12^control2&utm_term=霍尔编码器电机pid控制&spm=1018.2226.3001.4187)

[Stm32-使用TB6612驱动电机及编码器测速_tb6612电机驱动原理图_藕粉-的博客-CSDN博客](https://blog.csdn.net/cyaya6/article/details/129636599?ops_request_misc=%7B%22request%5Fid%22%3A%22169095757416800211529553%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169095757416800211529553&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129636599-null-null.142^v92^controlT0_2&utm_term=tb6612与编码器电机接线&spm=1018.2226.3001.4187)

#### **1.模块**

**使用电机驱动模块TB6612**

![image-20230804112241361](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230804112241361.png)

我的理解：这个芯片主要通过PWMA,AIN1,AIN2三个输入端来控制AO1,AO2两端的电压大小和电压极性，从而实现控制电机速度和方向的效果



**电机**

![image-20230804112631106](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230804112631106.png)

然后我们可以看到电机中间的两条线就是编码器的信号线，主要是用来计算脉冲数的，连接到单片机定时器的channel上



在实验中我设置TIM1_CH1 TIM1_CH2作为定时器的编码器接口，TIM3_CH1作为pwm的产生源，TIM7作为基本定时器5ms中断一次

![image-20230804113340837](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230804113340837.png)

#### 2.基本原理

1.使用`定时器的PWM模式` 生成一个需要的 `占空比可调的 频率 符合要求`的方波信号。

方波信号的频率不宜过高或者过低，**过高容易导致电机驱动的晶闸管经常处于开关状态–发热巨大**；**过低则容易产生噪音，对电机也低频的冲击**（pwm设置了为1KHZ，占空比一开始为0）



**2.编码器测速**

 采用的是`编码器模式3，在TI1和TI2边沿都计数`，也就是在`一个周期内对A相和B相的上升沿下降沿都计数`，`一个周期内计4次`，所以采用这种模式后,相应的计数值（CNT）就会变成4倍，这就是很多资料里说的`四倍频计数`。（就是说电机转一圈会产生4个脉冲）

#### 3.代码

main.c

```c++
    //开启PWM
  HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_1);
  //开启定时器
  HAL_TIM_Base_Start_IT(&htim7);
  /*打开编码器捕获*/
  HAL_TIM_Encoder_Start(&htim1,TIM_CHANNEL_ALL);
```



Tim.c

```c++
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	short fSpeed;
	short ERROR;
	static uint8_t i = 0;
 	
 	/*判断当进入定时器7中断时*/
	if(htim->Instance == TIM7)
	{
		fSpeed = GetSpeed();			//获取当前速度	
		speed += PID_Cal(fSpeed,&ERROR);//当前PWM数值加上增量式PID计算所得
        //speed =Incremental_PI_A (fSpeed ,TargetSpeed);

		
		//限制PWM最大范围
		if(speed>500)speed = 500;
		else if(speed<1)speed = 1;
	
		//将PID计算后的PWM写入系统
		SetMotorVoltageAndDirection(speed);

		/* 每隔（5*100）ms打印一次速度数据 */
		i++;
		if(i >= 100)
		{
			i = 0;
			ToggLED0();
			printf("速度数据为%d\n",fSpeed);
			printf("目标速度为%d\n",TargetSpeed);
			printf("误差为%d\n",ERROR);
            
		}
	}
}
```



Control.c

```c++
#include "Contral.h"

/******************************
	功能：每5ms在定时器中执行一次，
				获取电机速度SPEED
	返回值：电机速度SPEED
	形参：无
*******************************/
short GetSpeed()
{
	short SPEED=0 ;
	//SPEED = (short)(__HAL_TIM_GET_COUNTER(&htim1)*100)/(4*13*30);
   
    SPEED = (short)(TIM1 -> CNT*100)/(4*13*30);
	 TIM1 -> CNT=0;//查看定时器计数器的值
	return SPEED;
}

*******************************/
    根据增量式离散PID公式 
pwm+=Kp[e（k）-e(k-1)]+Ki*e(k)+Kd[e(k)-2e(k-1)+e(k-2)]
e(k)代表本次偏差 
e(k-1)代表上一次的偏差  以此类推    
**************************************************************************/
short PID_Cal(short Speed,short *error)
{
	short Error = TargetSpeed - Speed;
	static short Error_last = 0,Error_prev = 0;
	short pwm_add=0;
	*error = Error;
	pwm_add = kp*(Error - Error_last) + ki*Error + kd*(Error-2.0f*Error_last+Error_prev);
	
	Error_prev = Error_last;	  	    // 保存上上次误差
    Error_last = Error;	              // 保存上次偏差
	
	
	return pwm_add;
}


/******************************
	功能：判断电机正反转，
			并将计算所得的PWM数值
			写入单片机中
	返回值：无
	形参：无
*******************************/
void SetMotorVoltageAndDirection(float Pwm)
{
	if(Pwm<0)
	{
		BIN1(GPIO_PIN_RESET);
		BIN2(GPIO_PIN_SET);
	}
	else if(Pwm>0)
	{
		BIN1(GPIO_PIN_SET);
		BIN2(GPIO_PIN_RESET);
	}
	Pwm = fabs(Pwm);
  TIM3->CCR1 = Pwm;
}
```



# 4.机器人的控制模式

![image-20230801112257610](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230801112257610.png)

主要需要理解:

**ROS控制，航模控制，CAN控制，串口控制**



## 4.1 ROS控制（上下位机通信）

### 1.STM32向ROS发送数据

#### 数据格式

ROS 和 STM32 控制器（运动底盘）之间通过串口实现通信，STM32 控制器使用的是串口 3，波特率是 115200。通信协议包括：STM32 控制器向 ROS 发送

数据，ROS 向 STM32 控制器发送数据。打开 STM32 控制器的源码，关于串口通信的代码都在 STM32 控制器的 usartx.c 文件。STM32 向 ROS 发送数据使用一个 date_task 的任务按照 20hz 的频率执行。

发送的数据包括：**帧头帧尾、机器人使能标志位、机器人 XYZ 三轴速度、IMU三轴加速度、三轴角速度、电池电压、数据校验位**,

<img src="C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20230801114319287.png" alt="image-20230801114319287" style="zoom:50%;" />

#### **需要注意的地方：**

   1. **放大后的浮点数强制转换成 short 型数据.**

      机器人 XYZ 三轴速度、加速度计、角速度计以及电池电压的原始数据是浮点型的数据（float，单精度浮点数，占用32位（4个字节）的内存空间），因为浮点型数据使用串口传输不方便.（short 占用2个字节，16位的内存空间）

​       因为浮点型数据使用串口传输不方便，所以这四个数据在发送之前先将浮点数放大一千倍（保留小数点后三位），再将放大后的浮点数强制转换成 short 型数据.

​      **为什么浮点型数据使用串口传输不方便？**

```
1.数据精度问题：浮点数是以二进制形式表示的，而串口通信通常是基于字节的数据传输。浮点数的精度通常是有限的，当将浮点数转换为字节序列进行传输时，可能会出现舍入误差或精度损失，导致接收端无法准确还原原始的浮点数。

2.数据格式问题：浮点数的内部表示通常使用IEEE 754标准，包括符号位、指数位和尾数位等组成。然而，在串口通信中，需要将浮点数转换为字节流进行传输，涉及到字节序和数据对齐等问题，增加了数据处理的复杂性。
```

将原始的float数据乘以1000，将其放大1000倍。这可以通过简单的乘法运算来实现。

```python
float_data = 1.2345
amplified_data = float_data * 1000
```

short数据类型一般范围在-32768到32767之间，超出该范围可能导致溢出问题。



**2.在发送前将 short 型数据拆分成两个 8 位的数据。**

获取short数据的低8位字节（LSB）：使用位运算和掩码操作，将short数据与0xFF做按位与操作，获取低8位字节。

```python
short_data = 1234
low_byte = short_data & 0xFF
```

获取short数据的高8位字节（MSB）：使用位移操作，将short数据向右位移8位，得到高8位字节。

```python
high_byte = (short_data >> 8) & 0xFF
```



**3.相应的，上位机端在接收到数据后，需要将接收到的数据两个 8 位数据合并后转换为 short 型，在缩小一千倍来进行单位的转换。**

将两个 8 位数据合并后转换为 short 型

我们的控制量单位是 mm/s(0.001m/s)，**控制量方向由高 8 位数据的最高位决定。**

![image-20230812171840428](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230812171840428.png)



![](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230812171840428.png)



 



#### **上下位机的数据结构体**

发送结构体

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230801145356254.png" alt="image-20230801145356254" style="zoom:80%;" />

接收结构体

![image-20230801145518669](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230801145518669.png)





### 2.实验

参考资料：[ROS为上位机与STM32为下位机串口通讯（一）_串口助手当作上位机,stm32当作下位机_Eleven-boy的博客-CSDN博客](https://blog.csdn.net/qq_38422317/article/details/95335967?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32上位机与下位机通信&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-95335967.142^v92^controlT0_2&spm=1018.2226.3001.4187)

[ROS机器人制作（三）—— ROS上位机与stm32进行串口通信_ros和stm32通信_云影点灯大师的博客-CSDN博客](https://blog.csdn.net/Treasureljc/article/details/128759170?ops_request_misc=%7B%22request%5Fid%22%3A%22169172269516800192240325%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169172269516800192240325&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-128759170-null-null.142^v92^controlT0_2&utm_term=ROS为上位机与STM32为下位机串口通讯&spm=1018.2226.3001.4187)

[ROS学习与分享一：ROS与STM32通讯应用（第一节：发送一个字符）_ros stm32通讯_Biscuitkids的博客-CSDN博客](https://blog.csdn.net/weixin_48848716/article/details/122294871)

串口调试参考资料：

[Minicom 串口调试利器_minicom打开串口_阿基米东的博客-CSDN博客](https://blog.csdn.net/lu_embedded/article/details/106309451?ops_request_misc=%7B%22request%5Fid%22%3A%22169180454916800197074533%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169180454916800197074533&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-106309451-null-null.142^v92^controlT0_2&utm_term=minicom&spm=1018.2226.3001.4187)

**1.基本命令**

**Linux查看usb串口命令**

```
ls -l /dev/tty*
```

给串口赋予权限

```
sudo chmod 666 /dev/ttyUSB0
```



**2.简单的上下位机通信**

参考资料：[ROS为上位机与STM32为下位机串口通讯（一）_串口助手当作上位机,stm32当作下位机_Eleven-boy的博客-CSDN博客](https://blog.csdn.net/qq_38422317/article/details/95335967?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32上位机与下位机通信&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-95335967.142^v92^controlT0_2&spm=1018.2226.3001.4187)

实验：20.shangxiaweijitx

使用的是实验室自制的控制板，上下位机使用的是串口2（usart2)

stm32

```c++
u16 times=0;
int arr[10] = {0,1,2,3,4,5,6,7,8,9};
int main(void)
{   
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	delay_init(168);		
	uart_init(115200);	    //波特率115200
	while(1)
	{
			times++;
			printf("%3d\r\n",times);
			if(times>=100) times=0; 
			delay_ms(100);   
	}
}

```

ROS端

serial_communication_pub.cpp

```c++
#include <string>
#include <ros/ros.h>// 包含ROS的头文件
#include <boost/asio.hpp>//包含boost库函数
#include <boost/bind.hpp>
#include <std_msgs/String.h>//ros定义的String数据类型

using namespace std;
using namespace boost::asio;//定义一个命名空间，用于后面的读写操作

unsigned char times_buf[5];//接收区

int main(int argc,char** argv)
{
    ros::init(argc,argv,"serial_communication_pub");//初始化节点
    ros::NodeHandle n;//创建节点句柄
    /*创建一个Publisher,发布名为chatter的topic,消息类型为std_msgs::String*/
    ros::Publisher chatter_pub = n.advertise<std_msgs::String>("chatter",1000);
    ros::Rate loop_rate(10);//设置循环频率10Hz

    io_service iosev;
    serial_port sp(iosev, "/dev/ttyUSB0");//定义传输的串口
    sp.set_option(serial_port::baud_rate(115200));//波特率115200
    sp.set_option(serial_port::flow_control());//串口选项允许更改流量控制，默认值0
    sp.set_option(serial_port::parity());//奇偶性，默认值为none
    sp.set_option(serial_port::stop_bits()); //停止位，默认值为1
    sp.set_option(serial_port::character_size(8));  //数据位，默认值为8

    while(ros::ok())
    {
        read(sp,buffer(times_buf));
        string str(&times_buf[0],&times_buf[4]);//将数组转化为字符串

        std_msgs::String msg;
        std::stringstream ss;
        ss << str;

        msg.data = ss.str();

        ROS_INFO("%s",msg.data.c_str());//打印接受到的字符串

        chatter_pub.publish(msg);         //发布消息

        ros::spinOnce();

        loop_rate.sleep();       
    }
    iosev.run();
    return 0;
}
```



serial_communication_sub.cpp

```c++
#include <ros/ros.h>
#include <std_msgs/String.h>

//接收到订阅消息后，进入消息回调函数执行任务
void chatterCallback(const std_msgs::String::ConstPtr& msg)
{
  ROS_INFO("I hear:%s",msg->data.c_str());
}

int main(int argc, char **argv)
{
    /* code for main function */
    ros::init(argc, argv, "serial_communication_sub");//初始化ROS节点
    
    ros::NodeHandle n;//创建节点句柄

    /*创建一个Subscriber，订阅名为chatter的话题，注册回调函数chatterCallback*/
    ros::Subscriber sub = n.subscribe("chatter", 1000, chatterCallback);
    
    ros::spin();//循环等待回调函数
    return 0;
}

```



## 4.2 航模控制（串口5作为航模信号接收）

背景知识：参考资料：[四旋翼飞行器12——飞控接收机的三种接收模式_sbus接收机与pwm区别_翟羽嚄的博客-CSDN博客](https://blog.csdn.net/mao_hui_fei/article/details/85726320?ops_request_misc=&request_id=&biz_id=102&utm_term=航模串口接收&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-85726320.142^v92^controlT0_2&spm=1018.2226.3001.4187)

[SIYI AK28 遥控器接收机的SBUS口与STM32通讯_sbus接收机连接电脑_Super—Zhang的博客-CSDN博客](https://blog.csdn.net/qq_43012692/article/details/120989787?ops_request_misc=%7B%22request%5Fid%22%3A%22169139361516777224441717%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=169139361516777224441717&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-120989787-null-null.142^v92^controlT0_2&utm_term=航模串口接收 SBUS&spm=1018.2226.3001.4187)

### 1.**SBUS**

全称是Serial Bus。

SBUS是Futaba公司定义的一种串口通信协议，Futaba的产品应用越来越广泛，不论是航模，无人机，还是机器人，遥控车，总能有它的身影。SBUS是一个接收机串行总线输出，通过这根总线，可以获得遥控器上所有通道的数据。目前很多模型及无人机电子设备都支持SBUS总线的接入。使用SBUS总线获取通道数据，效率高的，而且节省硬件资源，只需要一根线即可获取所有通道的数据。

S.bus使用RS232C串口的硬件协议作为自己的硬件运行基础。 **使用TTL电平，即3.3V。 使用负逻辑**，即低电平为“1”，高电平为“0”。 波特率：100000（100k），注意：不兼容波特率115200。


**硬件介绍**

和TTL串口信号相比，sbus的逻辑电平是反的，并且是硬件取反，软件取反是无效的；硬件取反的电路图如下：

![image-20230807153836178](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230807153836178.png)

### 协议介绍

参考资料：[由mbed控制的双叶S-BUS |姆贝德](https://os.mbed.com/users/Digixx/notebook/futaba-s-bus-controlled-by-mbed/)

S-BUS协议是用于控制舵机的串行协议。提供多达 16 个比例通道和两个数字通道。 该协议源自RS232协议。

串口配置为波特率100kbps，8位数据，偶校验(even)，2位停止位，无流控。

**一个字节 = 1 个起始位 + 8 个数据位 + 1 个奇偶校验位 + 2 个停止位 （8E2），波特率 = 100k 位/秒,最高位先发送。逻辑反转（高电平 = 1）**

数据格式：

```
[起始字节]  [数据1]  [数据2] ....[数据22]  [flag] [尾字节]
```

起始字节 = 11110000B （0xF0）

中间22个字节就是16个通道的数据了，为什么是16个通道？因为**22x8=11x16**，每个通道用11bit表示，范围是0-2047。波形图如下：

endbyte = 00000000b



基本而言，data1为ch1的低8位，data2的低3位为ch1的高三位，data2的高5位是ch2的低5位，data3的低6位是ch2的高6位，以此类推，如下图所示：

![image-20230807155938538](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230807155938538.png)



**实验：**

航模有三个基准值：

**中间值1023，下限值240，上限值1807**

实验：

18.sbus

usart.c

```c++
/*--------航模数据解析相关全局变量的定义-----------*/
 uint8_t UART5_RX_BUF[UART_REC_LEN]; //接收缓冲,最大USART_REC_LEN个字节.
 uint16_t UART5_RX_STA = 0; //接收状态标记
 uint8_t aRxBuffer1[RXBUFFERSIZE];		  //HAL库使用的串口接收缓冲

SBUS_CH_Struct tagSBUS_CH;                    //存放转换后的通道数据

/**************************************************
* 函数功能：	将sbus信号转换为通道值
* 参    数：  ucBuf为接收到的串口数据
* 返 回 值：  0代表成功，1代表失败
**************************************************/
unsigned char Update_sbus(unsigned char* ucBuf)
{
	if(ucBuf[23] == 0)
	{
		tagSBUS_CH.ucConnectState = 1;
		tagSBUS_CH.CH1 = ((int16_t)ucBuf[ 1] >> 0  | ((int16_t)ucBuf[ 2] << 8 )) & 0x07FF;
       // printf("tagSBUS_CH.CH1=%d\n",tagSBUS_CH.CH1);
		tagSBUS_CH.CH2 = ((int16_t)ucBuf[ 2] >> 3  | ((int16_t)ucBuf[ 3] << 5 )) & 0x07FF;
		tagSBUS_CH.CH3 = ((int16_t)ucBuf[ 3] >> 6  | ((int16_t)ucBuf[ 4] << 2 ) | (int16_t)ucBuf[ 5] << 10 ) & 0x07FF;
        printf("tagSBUS_CH.CH3=%d\n",tagSBUS_CH.CH3);
		tagSBUS_CH.CH4 = ((int16_t)ucBuf[ 5] >> 1  | ((int16_t)ucBuf[ 6] << 7 )) & 0x07FF;
		tagSBUS_CH.CH5 = ((int16_t)ucBuf[ 6] >> 4  | ((int16_t)ucBuf[ 7] << 4 )) & 0x07FF;
		tagSBUS_CH.CH6 = ((int16_t)ucBuf[ 7] >> 7  | ((int16_t)ucBuf[ 8] << 1 ) | (int16_t)ucBuf[9] << 9 ) & 0x07FF;
		tagSBUS_CH.CH7 = ((int16_t)ucBuf[ 9] >> 2  | ((int16_t)ucBuf[10] << 6 )) & 0x07FF;
		tagSBUS_CH.CH8 = ((int16_t)ucBuf[10] >> 5  | ((int16_t)ucBuf[11] << 3 )) & 0x07FF;
		tagSBUS_CH.CH9 = ((int16_t)ucBuf[12] << 0  | ((int16_t)ucBuf[13] << 8 )) & 0x07FF;
		tagSBUS_CH.CH10 = ((int16_t)ucBuf[13] >> 3 | ((int16_t)ucBuf[14] << 5 )) & 0x07FF;
		tagSBUS_CH.CH11 = ((int16_t)ucBuf[14] >> 6 | ((int16_t)ucBuf[15] << 2 ) | (int16_t)ucBuf[16] << 10 ) & 0x07FF;
		tagSBUS_CH.CH12 = ((int16_t)ucBuf[16] >> 1 | ((int16_t)ucBuf[17] << 7 )) & 0x07FF;
		tagSBUS_CH.CH13 = ((int16_t)ucBuf[17] >> 4 | ((int16_t)ucBuf[18] << 4 )) & 0x07FF;
		tagSBUS_CH.CH14 = ((int16_t)ucBuf[18] >> 7 | ((int16_t)ucBuf[19] << 1 ) | (int16_t)ucBuf[20] << 9 ) & 0x07FF;
		tagSBUS_CH.CH15 = ((int16_t)ucBuf[20] >> 2 | ((int16_t)ucBuf[21] << 6 )) & 0x07FF;
		tagSBUS_CH.CH16 = ((int16_t)ucBuf[21] >> 5 | ((int16_t)ucBuf[22] << 3 )) & 0x07FF;
		
		return 1;
	}
	else
	{
		tagSBUS_CH.ucConnectState = 0;
		return 0;
   	}
	
}

/**************************************************
* 函数功能：	信号接收中断回调函数
* 入口参数：  无
* 返 回 值：  无
**************************************************/
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	int i;
    ToggLED1();
	while (huart->Instance == UART5) //如果是串口1
	{
        ToggLED0();
		UART5_RX_BUF[UART5_RX_STA] = aRxBuffer1[0];
       // printf("aRxBuffer1[0]=%d\n",aRxBuffer1[0]);
		if (UART5_RX_STA == 0 && UART5_RX_BUF[UART5_RX_STA] != 0x0F) break; //帧头不对，丢掉
		UART5_RX_STA++;
		if (UART5_RX_STA > UART_REC_LEN) UART5_RX_STA = 0;  ///接收数据错误,重新开始接收
		if (UART5_RX_BUF[0] == 0x0F && UART5_RX_BUF[24] == 0x00 && UART5_RX_STA == 25)	//接受完一帧数据
		{
			Update_sbus(UART5_RX_BUF);
			for (i = 0; i<25; i++)		//清空缓存区
				UART5_RX_BUF[i] = 0;
			UART5_RX_STA = 0;
		}
		break;
	}
     HAL_UART_Receive_IT(&huart5, (uint8_t *)&aRxBuffer1, 1);//接收完一字节数据后，需要重新开启中断
}

```



main.c

```c++
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_UART5_Init();
  MX_USART1_UART_Init();
  /* USER CODE BEGIN 2 */
     printf("大只测试\n");
 HAL_UART_Receive_IT(&huart5, (uint8_t *)&aRxBuffer1, 1);
   LED0(1);
   LED1(1);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
  }
  /* USER CODE END 3 */
}

```



### 2.板子电路图

([富斯i6s航模遥控器sbus车船固定翼10通fsi6s凤凰G7模拟IA6B IA10B](https://s.1688.com/youyuan/index.htm?spm=a262i4.9165215.zhaohuo-detail-top.2.41005303UT4L0h&tab=imageSearch&imageType=https://gw.alicdn.com&imageAddress=//g-search1.alicdn.com/img/bao/uploaded/i2/1654220684/O1CN01b0m1x01GvJZM86517_!!1654220684.png_300x300.jpg))

![image-20230801163313771](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230801163313771.png)

![image-20230801163326291](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230801163326291.png)

![image-20230807163658896](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230807163658896.png)

HM_T就是UART5_R(串口5的接收端)

当接收到一帧数据，进入串口中断



# 5.陀螺仪

参考资料：[MPU9250的详细功能_技塑未来-苏导的博客-CSDN博客](https://blog.csdn.net/suxiang198/article/details/75529921/?ops_request_misc=&request_id=&biz_id=102&utm_term=MPU9250&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-75529921.142^v92^controlT0_2&spm=1018.2226.3001.4187)

MPU9250 数字运动处理器是一款 9 轴运动跟踪设备，在小型紧凑型 IC 中集成了 3 轴加速度计、3 轴磁力计和 3 轴陀螺仪。DMP 具有三个 16 位分辨率模数转换器，用于加速度计、磁力计和陀螺仪输出的数字化。该器件还具有用于数字 I/O 的独立电源、集成温度传感器和可编程中断。

**陀螺仪（测量角速度的传感器）**

**磁力计（用于测量磁场强度和方向的传感器）**

**加速度计**




## 5.1 基本介绍

基本介绍：[MPU9250数据转换_mpu9250磁场单位_轻舟已过万重山@的博客-CSDN博客](https://blog.csdn.net/weixin_44228113/article/details/128012565?ops_request_misc=%7B%22request%5Fid%22%3A%22169165112116800184142189%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=169165112116800184142189&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-128012565-null-null.142^v92^controlT0_2&utm_term=MPU9250测量单位&spm=1018.2226.3001.4187)

### **1 MPU9250介绍**

1）MPU9250 内部集成有 3 轴陀螺仪、3 轴加速度计和 3 轴磁力计
2）输出： 16 位的数字量;
3） 通过集成电路总线 接口和单片机进行数据交互
4）**传输速率：传输速率可达 400 kHz /s**
5）陀螺仪角速度测量范围：陀螺仪的角速度测量范围最高达±2000（° /s），具有良好的动态响应特性。
6）加速度计测量范围：加速度计的测量范围最大为±16g( g 为重力加速度)，静态测量精度高。
7）磁力计测量范围：磁力计采用高灵度霍尔型传感器进行数据采集，磁感应强度测量范围为±4800μT，可用于对偏航角的辅助测量。



### 2.数据转换

![image-20230810150918451](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230810150918451.png)



对**陀螺仪**来说，当函数输入为0时，对应的量程范围为 -250(°/s) ~ ＋250(°/s)；当函数输入为1时，对应的量程范围为 -500(°/s) ~ ＋500(°/s)，以此类推。

对**加速度**来说，当函数输入为0时，对应的量程范围为 -2×g(m/s²) ~ ＋2×g(m/s²)；当函数输入为1时，对应的量程范围为 -4×g(m/s²) ~ ＋4×g(m/s²)，以此类推(g为重力加速度)。


### 2.1 陀螺仪数据转换

//fsr:0,±250dps;1,±500dps;2,±1000dps;3,±2000dps

假设我们设置函数的输入为3，即陀螺仪满量程范围为**-2000(°/s) ~ ＋2000(°/s)。**
我们知道MPU9250输出都是16位的数字量，即输出的原始数据范围为 -32768 ~ ＋32768。它对应了陀螺仪的满量程范围，即当读到的数据为32768时，它的角速度为2000(°/s)。

假设我们读取到的数据为data，则

```
真实的角速度大小为：data×2000/32768(°/s)=data/16.384(°/s)。
```

转换为弧度制为：(data/16.384)×pi/180(rad/s)=data/938.734(rad/s)

### 2.2 加速度数据转换

//fsr:0,±2g;1,±4g;2,±8g;3,±16g

假设我们设置函数的输入为3，即加速度满量程范围为-16×g(m/s²) ~ ＋16×g(m/s²)。

MPU9250输出都是16位的数字量
即输出的原始数据范围为 -32768 ~ ＋32768。它对应了加速度的满量程范围，即当读到的数据为32768时，它的加速度为16×g(m/s²)。
假设我们读到的数据为data，则

```
真实的加速度大小为：data×16×9.8/32768(m/s²)=data/208.98(m/s²)
```

采用不同量程范围时进行数据的转换，其中data为读取到的原始数据。

![image-20230810151811227](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20230810151811227.png)



### 3.MPU9250详细功能

参考：https://blog.csdn.net/suxiang198/article/details/75529921/?ops_request_misc=&request_id=&biz_id=102&utm_term=MPU9250&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-75529921.142%5Ev92%5EcontrolT0_2&spm=1018.2226.3001.4187

**时钟**

MPU9250有两个内部时钟源，以及一个PLL。

内部时钟源：

![image-20230808171504139](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230808171504139.png)



**I2C接口**

MPU9250有两个可选I2C接口，一个用来连接外部的第三方传感器（I2C Master方式），另一个I2C接口可以用来发送Motion数据给外部的控制器（I2C Slave方式）。
当然这两个I2C接口都是可选的，连接外部的第三方传感器的I2C接口只有需要连接外部传感器时才用（而且性能有限）。而用来发送Motion数据的I2C接口也是可选的，因为和SPI接口是复用的，因此只能二选一。
MPU9250 I2C接口：
![image-20230808171927893](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230808171927893.png)



**第三方传感器的I2C接口**
    该接口用于接外部的第三方传感器，就是如果觉得MPU9250的9轴传感器还不够用，还可以外接第三方的传感器，比如压力传感器。
    这个附加I2C接口有两种模式，I2C Master Mode和Pass-Through Mode。
该I2C接口因为MPU9250的性能限制，其对于外部传感器的初始化管理必须要借助于外部控制器来完成才行。MPU9250中有一个bypass multiplexer的机制，可以将与外部控制器连接的I2C接口（SDA, SCL）直接bypass到**外部传感器的I2C接口（AUX_DA, AUX_CL）**。
**即连接着的外部传感器初始化时，MPU9250会通过bypass multiplexer的机制将其转接到外部控制器的I2C接口进行初始化配置，在配置完成后，MPU9250会关闭bypass multiplexer，接过对外部传感器的控制权，并获取外部传感器的数据。**

**发送Motion数据的I2C Slave**
引脚物理连接要求
**SDA, SCL**: 通常的I2C这两根引脚是开漏的，支持双向通信（即数据可以Master发往Slave,也可以从Slave发往Master），但是MPU9250的这两根引脚需要通过上拉电阻上拉到VDD，最高速率为400kHz。
I2C通信设备角色划分
**I2C通信分为Master和Slave角色**，Master角色可以在I2C线上置入Slave地址，对应的Slave就需要向Master做出ACK。
MPU9250的I2C地址
**MPU9250的I2C Slave地址为b110100X**，其中的X是由AD0引脚的电平来决定的，**这样的地址设置，可以在同一I2C总线上连接两个MPU9250的设备**。



**SPI接口**

MPU9250只有一个SPI接口（SPI Slave），四线（CS, SDO, SCLK, SDI），两根作为控制线，两根作为数据线。MPU9250作为SPI Slave角色。
CS线为片选，为低时选中，为高时不选。

**SPI功能特性**

1. 数据传输为MSB first, LSB last

2. 数据在SCLK的上升沿被锁定（latched）

3. 数据在SCLK的下降沿发送

4. SCLK最大频率为1MHz

5. SPI读写操作需要在16个或更多个时钟周期（2个或2个Bytes以上）。第一个Byte包括了SPI地址，接下来的Bytes为SPI data。第一个Byte的第一个Bit为读写标志（Read-1, Write-0）
6. 支持多个字节的读写。

![image-20230808172522362](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20230808172522362.png)

**自检**

自检用于对传感器的机械和电子部分进行测试，自检的触发是通过对应的self-test寄存器来激活的。
自检被激活时，传感器启动并产生输出信号，输出信号用于观察自检回复。

```
自检回复 = 传感器带自检输出 - 传感器不带自检输出
```

当自检回复的值在合理范围内，该部分自检就会通过。当自检回复超出合理范围，就表明该部分自检失败。



## 5.2 实验

参考资料：[STM32CubeIDE HAL库操作IIC （二）案例篇（MPU9250）_zateper的博客-CSDN博客](https://blog.csdn.net/u010779035/article/details/104362532?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32cubemx MPU9250&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-104362532.142^v92^controlT0_2&spm=1018.2226.3001.4187)

**重点参考**：[【CubeMX笔记】用I2C读取MPU9250数据_硬件iic读取mpu9250_喂死你wsn的博客-CSDN博客](https://blog.csdn.net/na2wo4/article/details/104453401?ops_request_misc=%7B%22request%5Fid%22%3A%22169164258016800184173696%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169164258016800184173696&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104453401-null-null.142^v92^controlT0_2&utm_term=stm32cubemx mpu9250&spm=1018.2226.3001.4187)

**实验代码：19.MPU9250文件夹**

```c++
/* 
第1个参数为I2C操作句柄
第2个参数为从机设备地址
第3个参数为从机寄存器地址
第4个参数为从机寄存器地址长度
第5个参数为收发的数据的起始地址
第6个参数为传输数据的大小
第7个参数为操作超时时间 
*/
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
typedef enum	//返回的结构体定义
{
  HAL_OK       = 0x00U,
  HAL_ERROR    = 0x01U,
  HAL_BUSY     = 0x02U,
  HAL_TIMEOUT  = 0x03U
} HAL_StatusTypeDef;

```

### 1.困惑问题

其中我们需要用到的是从机设备地址，从机寄存器地址，收发数据大小，9050的设备地址是0x68（AD0下拉），**且使用上面两个函数是需要将设备地址左移一位，所以是0x68<<1**，而寄存器地址下面列举几个本例子所需的：



困惑一天的问题就是

```c++
HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
```

**这两个函数要求从机设备地址左移一位**

**解释**：在 I2C 地址中，最低位被用作 Read/Write Bit，其中 0 表示写操作，1 表示读操作。而 HAL 库中的函数通常期望传入完整的 8 位地址，其中最低位用于指示读写操作。因此，当使用 HAL_I2C_Mem_Write 函数时，需要将从机地址左移一位，并将最低位设置为 0，以表示写操作。

例如，如果从机地址是 0x68，将其左移一位后为 0xD0（对应写操作）。

测试是否成功写入的部分代码：

```c++
     HAL_StatusTypeDef status;
    status=HAL_I2C_Mem_Read(&hi2c1, MPU9250_ADDR<<1, MPU_ACCEL_XOUTH_REG, I2C_MEMADD_SIZE_8BIT,buf,6, 0xff);
         HAL_Delay(100);  //延时100ms
if (status == HAL_OK) {
    // 操作成功
    printf("Write operation succeeded.\n");
} else if (status == HAL_ERROR) {
    // 一般性错误
    printf("Write operation failed with general error.\n");
} else if (status == HAL_BUSY) {
    // I2C 总线忙
    printf("Write operation failed: I2C bus is busy.\n");
} else if (status == HAL_TIMEOUT) {
    // 操作超时
    printf("Write operation timed out.\n");
} else {
    // 其他未知错误   
    printf("Write operation failed with unknown error.\n");
}
```



### 2.实验代码：

其中I2C的设置

<img src="C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20230810152556022.png" alt="image-20230810152556022" style="zoom: 67%;" />

main.c

主要代码

```c++
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_USART1_UART_Init();
  /* USER CODE BEGIN 2 */
  MPU9250_Init();
  printf("\r\n***************I2C Example 大只测试*******************************\r\n");
  while (1)
  {
    /* USER CODE END WHILE */
    MPU9250_task();
      HAL_Delay(2000);
    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}
```

mpu9250.c



```c++
#include "mpu9250.h"
#include<string.h>
#include "usart.h"
int Deviation_Count=0;//零点漂移计数
short gyro[3], accel[3],magnet[3], sensors;//三轴加速度陀螺仪数据
short Deviation_gyro[3],Original_gyro[3];    //陀螺仪静差 和原始数据
 int Flag_Mpu6050;  

void Read_DMP(void)
{
	           
}

/**************************************************************************
函数功能：MPU9250任务
入口参数：无
返回  值：无
**************************************************************************/
void MPU9250_task()
{
     // printf("\r\n***************I2C Example 大只1测试*******************************\r\n");

			 memcpy(Deviation_gyro,gyro,sizeof(gyro));
             // printf("Deviation_gyro[0]=%hd Deviation_gyro[1]=%hd Deviation_gyro[2]=%hd\n",Deviation_gyro[0],Deviation_gyro[1],Deviation_gyro[2]);
      
		    MPU_Get_Temperature();           //温度测量
			MPU_Get_Accelerometer(accel);	//得到加速度传感器数据
			MPU_Get_Gyroscope(gyro);	//得到陀螺仪数据
			MPU_Get_Magnetometer(magnet);//获取磁力计数据			  
    
} 


//初始化MPU9250
//返回值:0,成功
//    其他,错误代码
uint8_t MPU9250_Init(void)
{
    uint8_t res[1]={0};
    uint8_t WriteBuffer2[10]={0X80,0X00,0X82,0X11,0X01};
     printf("开始写入\n");
     HAL_StatusTypeDef status;
    status=HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1, MPU_PWR_MGMT1_REG, I2C_MEMADD_SIZE_8BIT,WriteBuffer2,1, 10);//复位MPU9250  
  //  uint8_t value = 0x00;
   // status=HAL_I2C_Mem_Write(&hi2c1, 0x68<<1,0X6B, I2C_MEMADD_SIZE_8BIT, &value,2, 100);
     HAL_Delay(100);  //延时100ms


    HAL_Delay(100);  //延时100ms
    HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1, MPU_PWR_MGMT1_REG, I2C_MEMADD_SIZE_8BIT,&WriteBuffer2[1],1, 1000);//唤醒MPU9250
     	
    MPU_Set_Gyro_Fsr(1);					        	//陀螺仪传感器,±500dps
	MPU_Set_Accel_Fsr(0);					       	 	//加速度传感器,±2g
    MPU_Set_Rate(50);						       	 	//设置采样率50Hz
    
    HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1, MPU_INT_EN_REG, I2C_MEMADD_SIZE_8BIT,&WriteBuffer2[1],1, 1000);//关闭所有中断
    HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1, MPU_USER_CTRL_REG, I2C_MEMADD_SIZE_8BIT,&WriteBuffer2[1],1, 1000);//I2C主模式关闭
	HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1, MPU_FIFO_EN_REG, I2C_MEMADD_SIZE_8BIT,&WriteBuffer2[1],1, 1000);//关闭FIFO
	HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1, MPU_INTBP_CFG_REG, I2C_MEMADD_SIZE_8BIT,&WriteBuffer2[2],1, 1000);//INT引脚低电平有效，开启bypass模式，可以直接读取磁力计
   
    HAL_I2C_Mem_Read(&hi2c1, MPU9250_ADDR<<1, MPU_DEVICE_ID_REG, I2C_MEMADD_SIZE_8BIT,res,8, 1000);//读取MPU6500的ID
     
    if(res[0]==MPU6500_ID) //器件ID正确
    {
        HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1,MPU_PWR_MGMT1_REG, I2C_MEMADD_SIZE_8BIT,&WriteBuffer2[4],8, 1000);//设置CLKSEL,PLL X轴为参考
      // MPU_Write_Byte(MPU9250_ADDR,MPU_PWR_MGMT1_REG,0X01);  	//设置CLKSEL,PLL X轴为参考
        HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1,MPU_PWR_MGMT2_REG, I2C_MEMADD_SIZE_8BIT,&WriteBuffer2[1],8, 1000);//设置CLKSEL,PLL X轴为参考
       //MPU_Write_Byte(MPU9250_ADDR,MPU_PWR_MGMT2_REG,0X00);  	//加速度与陀螺仪都工作
		MPU_Set_Rate(50);						       	//设置采样率为50Hz   
    }
	else return 1;
 
    HAL_I2C_Mem_Read(&hi2c1, AK8963_ADDR<<1,MAG_WIA, I2C_MEMADD_SIZE_8BIT,res,8, 1000);//读取AK8963 ID 
    if(res[0]==AK8963_ID)
    {
        HAL_I2C_Mem_Write(&hi2c1, AK8963_ADDR<<1,MAG_CNTL1, I2C_MEMADD_SIZE_8BIT,&WriteBuffer2[3],8, 1000);	//设置AK8963为单次测量模式
    }
	else return 1;

    return 0;
}

//设置MPU9250陀螺仪传感器满量程范围
//fsr:0,±250dps;1,±500dps;2,±1000dps;3,±2000dps
//返回值:0,设置成功
//    其他,设置失败 
uint8_t MPU_Set_Gyro_Fsr(uint8_t fsr)
{
    uint8_t res;
    uint8_t WriteBuffer1[10]={0X00,0X08,0X10,0X18};//fsr
    HAL_StatusTypeDef status;
    status=HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1,MPU_GYRO_CFG_REG, I2C_MEMADD_SIZE_8BIT,WriteBuffer1+8*fsr,8, 1000);	//设置陀螺仪满量程范围  
	if (status == HAL_OK) {
    // 写入数据成功
    // 继续执行其他操作
       res=0;
} 
    return res;
    
}

//设置MPU9250加速度传感器满量程范围
//fsr:0,±2g;1,±4g;2,±8g;3,±16g
//返回值:0,设置成功
//    其他,设置失败 

uint8_t MPU_Set_Accel_Fsr(uint8_t fsr)
{
    uint8_t res;
      uint8_t WriteBuffer1[10]={0X00,0X08,0X10,0X18};//fsr
     HAL_StatusTypeDef status;
    status=HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1,MPU_ACCEL_CFG_REG, I2C_MEMADD_SIZE_8BIT,WriteBuffer1+8*fsr,8, 1000);	//设置陀螺仪满量程范围  
	if (status == HAL_OK) {
    // 写入数据成功
    // 继续执行其他操作
       res=0;
}  
        return res;
}

//设置MPU9250的数字低通滤波器
//lpf:数字低通滤波频率(Hz)
//返回值:0,设置成功
//    其他,设置失败 
uint8_t MPU_Set_LPF(uint16_t lpf)
{
	uint8_t data[1]={0};
    uint8_t res;
	if(lpf>=188)data[0]=1;
	else if(lpf>=98)data[0]=2;
	else if(lpf>=42)data[0]=3;
	else if(lpf>=20)data[0]=4;
	else if(lpf>=10)data[0]=5;
	else data[0]=6; 
    
         HAL_StatusTypeDef status;
    status=HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1,MPU_CFG_REG, I2C_MEMADD_SIZE_8BIT,data,8, 1000);//设置数字低通滤波器 
	if (status == HAL_OK) {
    // 写入数据成功
    // 继续执行其他操作
        res=0;
} 
   return res;
}

//设置MPU9250的采样率(假定Fs=1KHz)
//rate:4~1000(Hz)
//返回值:0,设置成功
//    其他,设置失败 
uint8_t MPU_Set_Rate(uint16_t rate)
{
	uint8_t data;
	if(rate>1000)rate=1000;
	if(rate<4)rate=4;
	data=1000/rate-1;
    HAL_I2C_Mem_Write(&hi2c1, MPU9250_ADDR<<1,MPU_SAMPLE_RATE_REG, I2C_MEMADD_SIZE_8BIT,&data,8, 1000);//设置数字低通滤波器 
 	return MPU_Set_LPF(rate/2);	//自动设置LPF为采样率的一半
}

//得到温度值
//返回值:温度值(扩大了100倍)
short MPU_Get_Temperature(void)
{
    uint8_t buf[2]; 
    short raw;
	float temp;
	//MPU_Read_Len(MPU9250_ADDR,MPU_TEMP_OUTH_REG,2,buf); 
    HAL_I2C_Mem_Read(&hi2c1, MPU9250_ADDR<<1,MPU_TEMP_OUTH_REG, I2C_MEMADD_SIZE_8BIT,buf,2, 0xff);
    
    raw=((uint16_t)buf[0]<<8)|buf[1];  
    temp=21+((double)raw)/333.87;  
    printf("温度为：%f摄氏度\n",temp);
    return temp*100;
}


//得到陀螺仪值(原始值)
//gx,gy,gz:陀螺仪x,y,z轴的原始读数(带符号)
//返回值:0,成功
//    其他,错误代码
uint8_t MPU_Get_Gyroscope(short *gyro)
{
    uint8_t buf[6],res; 
     HAL_StatusTypeDef status;
    status=HAL_I2C_Mem_Read(&hi2c1, MPU9250_ADDR<<1,MPU_GYRO_XOUTH_REG, I2C_MEMADD_SIZE_8BIT,buf,6, 0xff);
	if (status == HAL_OK) {
    // 写入数据成功
    // 继续执行其他操作
        res=0;
    } 
	if(res==0)
	{
		if(Deviation_Count<CONTROL_DELAY)//开机前 读取陀螺仪零点
		{
		gyro[0] =(((uint16_t)buf[0]<<8)|buf[1]);  
		gyro[1] =(((uint16_t)buf[2]<<8)|buf[3]);  
		gyro[2]= (((uint16_t)buf[4]<<8)|buf[5]);
          printf("gyro[0]=%hd gyro[1]=%hd gyro[2]=%hd\n",gyro[0],gyro[1],gyro[2]);
	
		}
		else
		{  
		//Deviation_Count	=CONTROL_DELAY+1;	 //固定计数值			
		Original_gyro[0] =(((uint16_t)buf[0]<<8)|buf[1]);  //保存原始数据用于按键修改零点
		Original_gyro[1] =(((uint16_t)buf[2]<<8)|buf[3]);  
		Original_gyro[2]= (((uint16_t)buf[4]<<8)|buf[5]);			
			
		gyro[0] =Original_gyro[0]-Deviation_gyro[0];  //最终带去除零点漂移的数据
		gyro[1] =Original_gyro[1]-Deviation_gyro[1];  
		gyro[2]= Original_gyro[2]-Deviation_gyro[2];
        
        // printf("gyro[0]=%hd gyro[1]=%hd gyro[2]=%hd\n",gyro[0],gyro[1],gyro[2]);
		}
	} 	
    return res;
}

//得到加速度值(原始值)
//gx,gy,gz:陀螺仪x,y,z轴的原始读数(带符号)
//返回值:0,成功
//    其他,错误代码
uint8_t MPU_Get_Accelerometer(short *accel)
{
    //printf("\r\n***************I2C Example 大只1测试*******************************\r\n");
    uint8_t buf[6],res;  
    
     HAL_StatusTypeDef status;
    status=HAL_I2C_Mem_Read(&hi2c1, MPU9250_ADDR<<1, MPU_ACCEL_XOUTH_REG, I2C_MEMADD_SIZE_8BIT,buf,6, 0xff);
         HAL_Delay(100);  //延时100ms
if (status == HAL_OK) {
    // 操作成功
    printf("Write operation succeeded.\n");
} else if (status == HAL_ERROR) {
    // 一般性错误
    printf("Write operation failed with general error.\n");
} else if (status == HAL_BUSY) {
    // I2C 总线忙
    printf("Write operation failed: I2C bus is busy.\n");
} else if (status == HAL_TIMEOUT) {
    // 操作超时
    printf("Write operation timed out.\n");
} else {
    // 其他未知错误   
    printf("Write operation failed with unknown error.\n");
}

	if (status == HAL_OK) {
    // 写入数据成功
    // 继续执行其他操作
        res=0;
    } 

	if(res==0)
{
		accel[0] =((uint16_t)buf[0]<<8)|buf[1];  
		accel[1] =((uint16_t)buf[2]<<8)|buf[3];  
		accel[2] =((uint16_t)buf[4]<<8)|buf[5];
    printf("accel[0] = %u  accel[1] = %u  accel[2] = %u\n", accel[0], accel[1], accel[2]);
	} 	
    return res;
}


//得到磁力计值(原始值)
//mx,my,mz:磁力计x,y,z轴的原始读数(带符号)
//返回值:0,成功
//    其他,错误代码
uint8_t MPU_Get_Magnetometer(short *magnet)
{
    uint8_t buf[6],res;  
    uint8_t data=0X11;
    HAL_StatusTypeDef status;
    status= HAL_I2C_Mem_Read(&hi2c1, AK8963_ADDR<<1, MAG_XOUT_L, I2C_MEMADD_SIZE_8BIT,buf,6, 0xff);
	if (status == HAL_OK) {
    // 写入数据成功
    // 继续执行其他操作
        res=0;
    } 
	
	if(res==0)
	{
		magnet[0]=((uint16_t)buf[1]<<8)|buf[0];  
		magnet[1]=((uint16_t)buf[3]<<8)|buf[2];  
		magnet[2]=((uint16_t)buf[5]<<8)|buf[4];
	} 	
    HAL_I2C_Mem_Write(&hi2c1,AK8963_ADDR<<1,MAG_CNTL1, I2C_MEMADD_SIZE_8BIT,&data,8, 1000);//AK8963每次读完以后都需要重新设置为单次测量模式
    //MPU_Write_Byte(AK8963_ADDR,MAG_CNTL1,0X11); //AK8963每次读完以后都需要重新设置为单次测量模式
    return res;;
}
```



mpu9250.h

```c++
#ifndef MPU6050_H
#define MPU6050_H
#include "i2c.h"											  	  

void MPU9250_task(void);


#define CONTROL_DELAY		1000 //换算成实际时间是10秒

#define MPU9250_ADDR            0X68    //MPU9250的器件IIC地址
#define MPU6500_ID				0X71  	//MPU6500的器件ID

//MPU9250内部封装了一个AK8963磁力计,地址和ID如下:
#define AK8963_ADDR				0X0C	//AK8963的I2C地址
#define AK8963_ID				0X48	//AK8963的器件ID


//AK8963的内部寄存器
#define MAG_WIA					0x00	//AK8963的器件ID寄存器地址
#define MAG_CNTL1          	  	0X0A    
#define MAG_CNTL2            	0X0B

#define MAG_XOUT_L				0X03	
#define MAG_XOUT_H				0X04
#define MAG_YOUT_L				0X05
#define MAG_YOUT_H				0X06
#define MAG_ZOUT_L				0X07
#define MAG_ZOUT_H				0X08

//MPU6500的内部寄存器
#define MPU_SELF_TESTX_REG		0X0D	//自检寄存器X
#define MPU_SELF_TESTY_REG		0X0E	//自检寄存器Y
#define MPU_SELF_TESTZ_REG		0X0F	//自检寄存器Z
#define MPU_SELF_TESTA_REG		0X10	//自检寄存器A
#define MPU_SAMPLE_RATE_REG		0X19	//采样频率分频器
#define MPU_CFG_REG				0X1A	//配置寄存器
#define MPU_GYRO_CFG_REG		0X1B	//陀螺仪配置寄存器
#define MPU_ACCEL_CFG_REG		0X1C	//加速度计配置寄存器
#define MPU_MOTION_DET_REG		0X1F	//运动检测阀值设置寄存器
#define MPU_FIFO_EN_REG			0X23	//FIFO使能寄存器
#define MPU_I2CMST_CTRL_REG		0X24	//IIC主机控制寄存器
#define MPU_I2CSLV0_ADDR_REG	0X25	//IIC从机0器件地址寄存器
#define MPU_I2CSLV0_REG			0X26	//IIC从机0数据地址寄存器
#define MPU_I2CSLV0_CTRL_REG	0X27	//IIC从机0控制寄存器
#define MPU_I2CSLV1_ADDR_REG	0X28	//IIC从机1器件地址寄存器
#define MPU_I2CSLV1_REG			0X29	//IIC从机1数据地址寄存器
#define MPU_I2CSLV1_CTRL_REG	0X2A	//IIC从机1控制寄存器
#define MPU_I2CSLV2_ADDR_REG	0X2B	//IIC从机2器件地址寄存器
#define MPU_I2CSLV2_REG			0X2C	//IIC从机2数据地址寄存器
#define MPU_I2CSLV2_CTRL_REG	0X2D	//IIC从机2控制寄存器
#define MPU_I2CSLV3_ADDR_REG	0X2E	//IIC从机3器件地址寄存器
#define MPU_I2CSLV3_REG			0X2F	//IIC从机3数据地址寄存器
#define MPU_I2CSLV3_CTRL_REG	0X30	//IIC从机3控制寄存器
#define MPU_I2CSLV4_ADDR_REG	0X31	//IIC从机4器件地址寄存器
#define MPU_I2CSLV4_REG			0X32	//IIC从机4数据地址寄存器
#define MPU_I2CSLV4_DO_REG		0X33	//IIC从机4写数据寄存器
#define MPU_I2CSLV4_CTRL_REG	0X34	//IIC从机4控制寄存器
#define MPU_I2CSLV4_DI_REG		0X35	//IIC从机4读数据寄存器

#define MPU_I2CMST_STA_REG		0X36	//IIC主机状态寄存器
#define MPU_INTBP_CFG_REG		0X37	//中断/旁路设置寄存器
#define MPU_INT_EN_REG			0X38	//中断使能寄存器
#define MPU_INT_STA_REG			0X3A	//中断状态寄存器

#define MPU_ACCEL_XOUTH_REG		0X3B	//加速度值,X轴高8位寄存器
#define MPU_ACCEL_XOUTL_REG		0X3C	//加速度值,X轴低8位寄存器
#define MPU_ACCEL_YOUTH_REG		0X3D	//加速度值,Y轴高8位寄存器
#define MPU_ACCEL_YOUTL_REG		0X3E	//加速度值,Y轴低8位寄存器
#define MPU_ACCEL_ZOUTH_REG		0X3F	//加速度值,Z轴高8位寄存器
#define MPU_ACCEL_ZOUTL_REG		0X40	//加速度值,Z轴低8位寄存器

#define MPU_TEMP_OUTH_REG		0X41	//温度值高八位寄存器
#define MPU_TEMP_OUTL_REG		0X42	//温度值低8位寄存器

#define MPU_GYRO_XOUTH_REG		0X43	//陀螺仪值,X轴高8位寄存器
#define MPU_GYRO_XOUTL_REG		0X44	//陀螺仪值,X轴低8位寄存器
#define MPU_GYRO_YOUTH_REG		0X45	//陀螺仪值,Y轴高8位寄存器
#define MPU_GYRO_YOUTL_REG		0X46	//陀螺仪值,Y轴低8位寄存器
#define MPU_GYRO_ZOUTH_REG		0X47	//陀螺仪值,Z轴高8位寄存器
#define MPU_GYRO_ZOUTL_REG		0X48	//陀螺仪值,Z轴低8位寄存器

#define MPU_I2CSLV0_DO_REG		0X63	//IIC从机0数据寄存器
#define MPU_I2CSLV1_DO_REG		0X64	//IIC从机1数据寄存器
#define MPU_I2CSLV2_DO_REG		0X65	//IIC从机2数据寄存器
#define MPU_I2CSLV3_DO_REG		0X66	//IIC从机3数据寄存器

#define MPU_I2CMST_DELAY_REG	0X67	//IIC主机延时管理寄存器
#define MPU_SIGPATH_RST_REG		0X68	//信号通道复位寄存器
#define MPU_MDETECT_CTRL_REG	0X69	//运动检测控制寄存器
#define MPU_USER_CTRL_REG		0X6A	//用户控制寄存器
#define MPU_PWR_MGMT1_REG		0X6B	//电源管理寄存器1
#define MPU_PWR_MGMT2_REG		0X6C	//电源管理寄存器2 
#define MPU_FIFO_CNTH_REG		0X72	//FIFO计数寄存器高八位
#define MPU_FIFO_CNTL_REG		0X73	//FIFO计数寄存器低八位
#define MPU_FIFO_RW_REG			0X74	//FIFO读写寄存器
#define MPU_DEVICE_ID_REG		0X75	//器件ID寄存器


#define MPU9250_TASK_PRIO		3 //freertos相关
#define MPU9250_STK_SIZE 		256  //freertos相关 
uint8_t MPU9250_Init(void);
uint8_t MPU_WaitForReady(uint8_t devaddr);
uint8_t MPU_Read_Byte(uint8_t devaddr,uint8_t reg);
uint8_t MPU_Set_Gyro_Fsr(uint8_t fsr);
uint8_t MPU_Set_Accel_Fsr(uint8_t fsr);
uint8_t MPU_Set_Rate(uint16_t rate);

short MPU_Get_Temperature(void);

extern	short gyro[3], accel[3],magnet[3];
extern  short Deviation_gyro[3],Original_gyro[3];
extern int Flag_Mpu6050;  
extern int Deviation_Count;
uint8_t MPU_Get_Gyroscope(short *gyro);
uint8_t MPU_Get_Accelerometer(short *accel);
uint8_t MPU_Get_Magnetometer(short *magnet);

#endif
```



### 3.实验结果

该结果单位还没进行转换

![image-20230810152330078](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20230810152330078.png)





# 6.使用驱动驱动电机
